# app.py
# -*- coding: utf-8 -*-
"""
ì—¬ê³ ìƒ ëŒ€ìƒ ê³ ë¯¼ìƒë‹´ ì›¹ì•± (Streamlit)
- ìƒë…„ì›”ì¼ ì…ë ¥ â†’ ë³„ìë¦¬/ê°„ë‹¨ ì‚¬ì£¼í’(ì˜¤í–‰/ë ) ì¶”ì •
- 4ê°œ ì¹´í…Œê³ ë¦¬: í•™ì—…, ì—°ì• , ìš´ì„¸, ì§„ë¡œìƒë‹´
- ì¹´í…Œê³ ë¦¬ë³„ ë§ì¶¤ ì¡°ì–¸/í•´ê²°ì±… ìƒì„± + í•  ì¼ ì²´í¬ë¦¬ìŠ¤íŠ¸
- íƒœì–´ë‚œ "ë‹¬" Ã— ì¹´í…Œê³ ë¦¬ ì¡°í•©(12 Ã— 4 = 48)ì— ë§ì¶˜ ì‹¬ì‹  ì•ˆì • ë°°ê²½ìŒì•…
    - 1) ì‚¬ìš©ì ì—…ë¡œë“œ(ê¶Œì¥): mp3/wav/flac ë“± 48ê°œ íŒŒì¼ ë§¤í•‘
    - 2) URL ì¬ìƒ: ê° ì¡°í•©ì— URLì„ ì„¤ì • ê°€ëŠ¥ (config íƒ­)
    - 3) ë‚´ì¥ ìƒì„± BGM: í•©ì„±(ì‚¬ì¸íŒŒ/ì„œë¸Œë² ì´ìŠ¤/ì•°ë¹„ì–¸ìŠ¤)ë¡œ ì¦‰ì„ ìƒì„± (ê¸°ë³¸ê°’)

ì‚¬ìš©ë²•
- streamlit run app.py
- ì¢Œì¸¡ ì‚¬ì´ë“œë°”ì—ì„œ ìƒë…„ì›”ì¼, ì¹´í…Œê³ ë¦¬, ê³ ë¯¼ ì…ë ¥ í›„ ê²°ê³¼ ë³´ê¸°
- BGM: ì—…ë¡œë“œ/URL/ë‚´ì¥ ì¤‘ ì„ íƒ. ì—…ë¡œë“œëŠ” íŒŒì¼ëª…ì„ "MM-ì¹´í…Œê³ ë¦¬-ì œëª©.ext" ê·œì¹™ ì¶”ì²œ (ì˜ˆ: 03-í•™ì—…-ë´„ì˜_ì—°ìŠµê³¡.mp3)
"""

import io
import math
import datetime as dt
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional

import numpy as np
import streamlit as st

# ----------------------------- ìƒìˆ˜/ìœ í‹¸ -----------------------------
CATEGORIES = ["í•™ì—…", "ì—°ì• ", "ìš´ì„¸", "ì§„ë¡œìƒë‹´"]
MONTHS_KR = ["1ì›”", "2ì›”", "3ì›”", "4ì›”", "5ì›”", "6ì›”", "7ì›”", "8ì›”", "9ì›”", "10ì›”", "11ì›”", "12ì›”"]

@dataclass
class UserProfile:
    name: str
    birthdate: dt.date
    zodiac: str  # ì„œì–‘ ë³„ìë¦¬
    zodiac_animal: str  # 12ë (ê°„ë‹¨)
    element: str  # ì˜¤í–‰(ê°„ë‹¨ ë§¤í•‘)

# ----------------------------- ë³„ìë¦¬/ë /ì˜¤í–‰ -----------------------------

def western_zodiac(d: dt.date) -> str:
    # ë‚ ì§œ ê²½ê³„ëŠ” ì¼ë°˜ì  ê¸°ì¤€ ì‚¬ìš©
    zds = [
        ((1, 20), "ë¬¼ë³‘ìë¦¬"), ((2, 19), "ë¬¼ê³ ê¸°ìë¦¬"), ((3, 21), "ì–‘ìë¦¬"),
        ((4, 20), "í™©ì†Œìë¦¬"), ((5, 21), "ìŒë‘¥ì´ìë¦¬"), ((6, 22), "ê²Œìë¦¬"),
        ((7, 23), "ì‚¬ììë¦¬"), ((8, 23), "ì²˜ë…€ìë¦¬"), ((9, 23), "ì²œì¹­ìë¦¬"),
        ((10, 24), "ì „ê°ˆìë¦¬"), ((11, 23), "ì‚¬ìˆ˜ìë¦¬"), ((12, 22), "ì—¼ì†Œìë¦¬"),
    ]
    m, day = d.month, d.day
    for (edge_m, edge_d), name in zds:
        if (m, day) < (edge_m, edge_d):
            return prev_name
        prev_name = name
    return "ì—¼ì†Œìë¦¬"


def korean_zodiac_animal(year: int) -> str:
    # 0:ì¥â€¦ 11:ë¼ì§€ â€” 2008(ì¥) ê¸°ì¤€
    animals = ["ì¥", "ì†Œ", "í˜¸ë‘ì´", "í† ë¼", "ìš©", "ë±€", "ë§", "ì–‘", "ì›ìˆ­ì´", "ë‹­", "ê°œ", "ë¼ì§€"]
    idx = (year - 2008) % 12
    return animals[idx]


def element_from_month(month: int) -> str:
    # ê°„ë‹¨ ì˜¤í–‰ ë§¤í•‘ (ì›”ê¸°ì¤€)
    mapping = {
        1: "ìˆ˜", 2: "ìˆ˜", 3: "ëª©", 4: "ëª©", 5: "í™”", 6: "í™”",
        7: "í† ", 8: "í† ", 9: "ê¸ˆ", 10: "ê¸ˆ", 11: "ìˆ˜", 12: "ìˆ˜",
    }
    return mapping.get(month, "í† ")

# ----------------------------- ì¡°ì–¸ ìƒì„± -----------------------------

def seed_rng(date: dt.date, category: str) -> np.random.Generator:
    seed = int(date.strftime("%m%d")) * 100 + (CATEGORIES.index(category) + 1)
    return np.random.default_rng(seed)


def advice_blocks(profile: UserProfile, category: str, concern: str) -> Tuple[str, List[str], List[str]]:
    """ê°„ê²° ì¡°ì–¸(ìš”ì•½), ì‹¤í–‰ ì²´í¬ë¦¬ìŠ¤íŠ¸, ìœ„ë¡œ/ê²©ë ¤ ë©”ì‹œì§€ ë°˜í™˜"""
    rng = seed_rng(profile.birthdate, category)
    tone_words = {
        "ìˆ˜": ("ì°¨ë¶„í•¨", "ì •ë¦¬"),
        "ëª©": ("ì„±ì¥", "ê³„íš"),
        "í™”": ("ì¶”ì§„", "ìš©ê¸°"),
        "í† ": ("ì§‘ì¤‘", "ê¾¸ì¤€í•¨"),
        "ê¸ˆ": ("ê· í˜•", "ì ˆì œ"),
    }
    t1, t2 = tone_words.get(profile.element, ("ê· í˜•", "ì •ë¦¬"))

    if category == "í•™ì—…":
        summary = f"{profile.zodiac}ì˜ ì„±í–¥ì„ ì‚´ë ¤ {t1}í•˜ê²Œ ë£¨í‹´ì„ ì¡ì•„ë³´ì. í•µì‹¬ì€ {t2}ì™€ ê°€ë²¼ìš´ ë°˜ë³µì´ë‹¤."
        tasks = [
            "ì˜¤ëŠ˜ 25ë¶„ Ã— 3ì„¸íŠ¸ ì§‘ì¤‘(í¬ëª¨ë„ë¡œ)",
            f"ì·¨ì•½ ê³¼ëª© 1ê°œë§Œ ì„ íƒí•´ í•µì‹¬ ê°œë… 3ê°œ ì •ë¦¬ ({profile.element}ì˜ í‚¤ì›Œë“œ í™œìš©)",
            "í•™ìŠµ ë£¨í‹´(ì‹œì‘ ì‹œê°„/ì¥ì†Œ) ê³ ì • â€” 3ì¼ë§Œ ì‹¤í—˜",
            "ë‚´ì¼ ì•„ì¹¨ í™•ì¸ í…ŒìŠ¤íŠ¸ 5ë¬¸ì œ ë§Œë“¤ê¸°",
        ]
        support = [
            "ì™„ë²½ë³´ë‹¤ ì§„í–‰ì´ ë” ì¤‘ìš”í•´. ì‘ì€ ìŠ¹ë¦¬ë¥¼ ìŒ“ì.",
            f"{profile.birthdate.month}ì›”ì˜ íë¦„ì—” ìƒˆ ë£¨í‹´ì´ ì˜ ë¶™ëŠ” ì‹œê¸°ì•¼.",
        ]

    elif category == "ì—°ì• ":
        summary = f"ì†Œí†µì˜ ì˜¨ë„ë¥¼ {t1}í•˜ê²Œ ìœ ì§€í•˜ì. ì†”ì§í•˜ë˜, ì†ë„ë¥¼ {t2}ë¡œ ì¡°ì ˆí•˜ê¸°."
        tasks = [
            "ë©”ì‹œì§€/ëŒ€í™”ì—ì„œ 'ì‚¬ì‹¤ ë‚˜ëŠ”â€¦'ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” 1ë¬¸ì¥ ì†”ì§í•¨",
            "ìƒëŒ€ ê°•ì  1ê°œ ì¹­ì°¬ + êµ¬ì²´ ì˜ˆì‹œ", 
            "ë°”ë¼ëŠ” ì  1ê°œë¥¼ I-Messageë¡œ ë§í•˜ê¸°", 
            "ì„œë¡œ ì•½ì† 1ê°œ(ì‹œê°„/ì—°ë½ ë¹ˆë„) í•©ì˜",
        ]
        support = [
            "ê´€ê³„ëŠ” íŒ€í”Œì´ì•¼. ë„ˆë§Œì˜ í˜ì´ìŠ¤ë¥¼ ì¡´ì¤‘í•´ë„ ì¢‹ì•„.",
            f"{profile.zodiac}ì˜ ë§¤ë ¥ í¬ì¸íŠ¸ë¥¼ ë¯¿ì–´ë´ â€” ë„¤ê°€ ìƒê°í•˜ëŠ” ê²ƒë³´ë‹¤ ì¶©ë¶„í•´.",
        ]

    elif category == "ìš´ì„¸":
        summary = f"ì˜¤ëŠ˜ì˜ í‚¤ì›Œë“œëŠ” '{t1}'. ê³¼ê°í•œ ê²°ì •ë³´ë‹¤ ì‘ì€ ì •ëˆì´ í–‰ìš´ì„ ë¶€ë¥¸ë‹¤."
        tasks = [
            "ì±…ìƒ/ê°€ë°© 10ë¶„ ì •ë¦¬ (ë²„ë¦´ ê²ƒ 3ê°œ)",
            "í•  ì¼ 3ê°€ì§€ë§Œ ì¨ì„œ ìš°ì„ ìˆœìœ„ í‘œì‹œ",
            "ë¬¼ 1ì»µ ë” ë§ˆì‹œê¸°, 10ë¶„ ì‚°ì±…",
            "í•˜ë£¨ í‰ê°€: ì˜í•œ ì¼ 1ê°€ì§€ ê¸°ë¡",
        ]
        support = [
            "ìš´ì€ ì¤€ë¹„ëœ ì‚¬ëŒì„ ì¢‹ì•„í•´. ì •ë¦¬=ì¤€ë¹„ì•¼.",
            f"{profile.element} ê¸°ìš´ì´ ë†’ì€ ë‚ . ë¦¬ë“¬ì„ íƒ€ë³´ì.",
        ]

    else:  # ì§„ë¡œìƒë‹´
        summary = f"ê´€ì‹¬ì˜ í”ì ì„ ëª¨ì•„ë³´ê¸°. {t1}í•œ íƒìƒ‰ê³¼ {t2}ê°€ ì§„ë¡œ íŒíŠ¸ë¥¼ ì¤€ë‹¤."
        tasks = [
            "ì´ë²ˆ ì£¼ 'ì¬ë°Œì—ˆë‹¤' ìˆœê°„ 3ê°œ ê¸°ë¡",
            "ì§ì—…/ì „ê³µ í‚¤ì›Œë“œ 5ê°œ ë½‘ì•„ ìœ„í‚¤/ìœ íŠœë¸Œ 15ë¶„ ìŠ¤ìº”",
            "í•™êµ/ì§€ì—­ í–‰ì‚¬ 1ê°œ ì°¸ì—¬ ì‹ ì²­",
            "ì„ ë°°/êµì‚¬ì—ê²Œ 1ê°œ ì§ˆë¬¸ ë³´ë‚´ê¸°",
        ]
        support = [
            "ì§„ë¡œëŠ” ë°œê²¬í˜• í¼ì¦. ì¡°ê°ì„ ëª¨ìœ¼ë©´ ê·¸ë¦¼ì´ ë³´ì—¬.",
            "ì‘ê²Œ ì›€ì§ì´ëŠ” ê²Œ ì œì¼ í° íŒíŠ¸ê°€ ë¼.",
        ]

    # ê³ ë¯¼ í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ìš”ì•½ì— ì‚´ì§ ë°˜ì˜
    if concern.strip():
        summary += f" (ê³ ë¯¼: '{concern[:30] + ('â€¦' if len(concern) > 30 else '')}')"

    # RNGë¡œ 1~2ê°œ í•­ëª©ì„ ê°•ì¡°
    if len(tasks) > 0:
        idx = rng.integers(0, len(tasks))
        tasks[idx] = "âœ… " + tasks[idx]

    return summary, tasks, support

# ----------------------------- 48ê°œ BGM ë§¤í•‘ -----------------------------

@dataclass
class TrackInfo:
    title: str
    url: Optional[str]  # ì›ê²© URL(ìˆìœ¼ë©´ ì‚¬ìš©)
    file_key: Optional[str]  # ì—…ë¡œë“œ íŒŒì¼ ë§¤ì¹­ í‚¤(ì—†ìœ¼ë©´ None)

# ê¸°ë³¸ ë§¤í•‘: "ì›”(1~12)-ì¹´í…Œê³ ë¦¬" â†’ íŠ¸ë™ ìŠ¬ë¡¯
# URLì€ ë¹ˆ ê°’(None)ìœ¼ë¡œ ë‘ê³ , Config íƒ­ì—ì„œ ì‚¬ìš©ì ì •ì˜ ê°€ëŠ¥

def default_music_map() -> Dict[str, TrackInfo]:
    mapping: Dict[str, TrackInfo] = {}
    for m in range(1, 13):
        for c in CATEGORIES:
            key = f"{m:02d}-{c}"
            # íƒ€ì´í‹€ì€ ì›”/ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ìœ¼ë¡œ ìë™ ìƒì„±
            title = f"{MONTHS_KR[m-1]} Â· {c} Â· Calming"
            mapping[key] = TrackInfo(title=title, url=None, file_key=key)
    return mapping

# ----------------------------- í•©ì„± BGM ìƒì„±ê¸° -----------------------------

def adsr_envelope(n: int, sr: int, a=0.05, d=0.1, s=0.7, r=0.2) -> np.ndarray:
    a_n = int(a * sr)
    d_n = int(d * sr)
    r_n = int(r * sr)
    s_n = n - (a_n + d_n + r_n)
    if s_n < 0:
        s_n = 0
    env = np.zeros(n)
    # Attack
    if a_n > 0:
        env[:a_n] = np.linspace(0, 1, a_n)
    # Decay
    if d_n > 0:
        env[a_n:a_n+d_n] = np.linspace(1, s, d_n)
    # Sustain
    env[a_n+d_n:a_n+d_n+s_n] = s
    # Release
    if r_n > 0:
        env[-r_n:] = np.linspace(s, 0, r_n)
    return env


def synth_ambient(duration_s: int, seed: int, base_hz: float = 220.0, sr: int = 44100) -> bytes:
    rng = np.random.default_rng(seed)
    t = np.linspace(0, duration_s, duration_s * sr, endpoint=False)

    # 2~3ê°œì˜ ì‚¬ì¸íŒŒ + ì„œë¸Œë² ì´ìŠ¤ + ì†ŒëŸ‰ì˜ ë…¸ì´ì¦ˆ
    freqs = [base_hz,
             base_hz * (5/4),  # ì¥3ë„
             base_hz * (3/2)]  # ì™„ì „5ë„
    # ì›”/ì¹´í…Œê³ ë¦¬ë§ˆë‹¤ ë¯¸ì„¸ detune
    detunes = rng.normal(0, 0.3, size=len(freqs))

    sig = np.zeros_like(t)
    for f, dtn in zip(freqs, detunes):
        sig += 0.33 * np.sin(2 * np.pi * (f + dtn) * t)

    # ì„œë¸Œë² ì´ìŠ¤
    sig += 0.1 * np.sin(2 * np.pi * (base_hz/2) * t)

    # ë¶€ë“œëŸ¬ìš´ ë…¸ì´ì¦ˆ íŒ¨ë“œ
    noise = rng.normal(0, 0.02, size=len(t))
    sig += noise

    # ê°„ë‹¨í•œ ì €ì—­ í†µê³¼ ëŠë‚Œ: ì´ë™ í‰ê· 
    k = int(sr * 0.01)
    if k > 1:
        kernel = np.ones(k) / k
        sig = np.convolve(sig, kernel, mode='same')

    # ADSR ì ìš©
    env = adsr_envelope(len(sig), sr, a=0.2, d=0.6, s=0.6, r=0.8)
    sig = sig * env

    # ì •ê·œí™”
    sig = sig / (np.max(np.abs(sig)) + 1e-9) * 0.9

    # WAVë¡œ ì¸ë©”ëª¨ë¦¬ ì €ì¥
    import wave, struct
    buf = io.BytesIO()
    with wave.open(buf, 'wb') as wf:
        wf.setnchannels(2)
        wf.setsampwidth(2)  # 16-bit
        wf.setframerate(sr)
        # ìŠ¤í…Œë ˆì˜¤: L=ì›ì‹ í˜¸, R=ì•½ê°„ ìœ„ìƒ ì´ë™
        phase_shift = int(0.002 * sr)
        r_sig = np.roll(sig, phase_shift)
        interleaved = np.vstack((sig, r_sig)).T
        for sL, sR in interleaved:
            wf.writeframesraw(struct.pack('<h', int(sL * 32767)))
            wf.writeframesraw(struct.pack('<h', int(sR * 32767)))
    return buf.getvalue()

# ----------------------------- UI êµ¬ì„± -----------------------------

st.set_page_config(page_title="ê³ ë¯¼ìƒë‹´ â€” ì—¬ê³ ìƒ ë§ì¶¤", page_icon="ğŸ’¬", layout="wide")

if "music_map" not in st.session_state:
    st.session_state.music_map = default_music_map()
if "uploaded_audio" not in st.session_state:
    st.session_state.uploaded_audio: Dict[str, bytes] = {}
if "chat" not in st.session_state:
    st.session_state.chat: List[Tuple[str, str]] = []  # (role, text)

st.title("ì—¬ê³ ìƒ ë§ì¶¤ ê³ ë¯¼ìƒë‹´ ğŸ’¬âœ¨")

with st.sidebar:
    st.header("ê¸°ë³¸ ì •ë³´")
    name = st.text_input("ì´ë¦„ (ì„ íƒ)", placeholder="ë‹‰ë„¤ì„ë„ ì¢‹ì•„ìš”")
    birth = st.date_input("ìƒë…„ì›”ì¼", value=dt.date(2007, 1, 1), format="YYYY-MM-DD")
    category = st.selectbox("ìƒë‹´ ì¹´í…Œê³ ë¦¬", CATEGORIES, index=0)
    concern = st.text_area("ì§€ê¸ˆ ê³ ë¯¼ í•œ ì¤„", placeholder="ì˜ˆ: ìˆ˜í•™ ì ìˆ˜ê°€ ì•ˆ ì˜¤ë¥´ê³  ìˆì–´ìš”â€¦")

    # BGM ì„¤ì •
    st.subheader("ë°°ê²½ìŒì•… ì„¤ì • ğŸ§")
    bgm_mode = st.radio("ì¬ìƒ ë°©ì‹", ["ë‚´ì¥ ìƒì„± BGM", "ì˜¤ë””ì˜¤ ì—…ë¡œë“œ", "URL ë§¤í•‘"], index=0)

    if bgm_mode == "ì˜¤ë””ì˜¤ ì—…ë¡œë“œ":
        up_files = st.file_uploader(
            "ìµœëŒ€ 48ê°œ ì—…ë¡œë“œ (íŒŒì¼ëª…: MM-ì¹´í…Œê³ ë¦¬-ì œëª©.ext ê¶Œì¥)",
            type=["mp3", "wav", "flac", "ogg"], accept_multiple_files=True,
        )
        if up_files:
            for f in up_files:
                key_guess = None
                try:
                    fname = f.name
                    # íŒŒì¼ëª…ì—ì„œ í‚¤ ì¶”ì¶œ: 01-í•™ì—…-...
                    parts = fname.split("-")
                    if len(parts) >= 2 and parts[0].isdigit():
                        mon = int(parts[0])
                        cat = parts[1].split(".")[0]
                        if cat in CATEGORIES and 1 <= mon <= 12:
                            key_guess = f"{mon:02d}-{cat}"
                except Exception:
                    pass
                raw = f.read()
                if key_guess:
                    st.session_state.uploaded_audio[key_guess] = raw
                else:
                    # ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ ë³´ê´€í•¨ì— ë„£ê³ , Config íƒ­ì—ì„œ ìˆ˜ë™ ë§¤í•‘ ìœ ë„
                    st.session_state.uploaded_audio[f.name] = raw
            st.success(f"ì—…ë¡œë“œ ì™„ë£Œ: {len(up_files)}ê°œ íŒŒì¼")

    elif bgm_mode == "URL ë§¤í•‘":
        st.info("ì•„ë˜ 'ì„¤ì •/ê´€ë¦¬' íƒ­ì—ì„œ ì›”Ã—ì¹´í…Œê³ ë¦¬ë³„ URLì„ ì…ë ¥í•˜ì„¸ìš”.")

# í”„ë¡œí•„ ìƒì„±
profile = UserProfile(
    name=name.strip() or "ìµëª…",
    birthdate=birth,
    zodiac=western_zodiac(birth),
    zodiac_animal=korean_zodiac_animal(birth.year),
    element=element_from_month(birth.month),
)

# ë©”ì¸ ë ˆì´ì•„ì›ƒ
colL, colR = st.columns([7, 5], gap="large")

with colL:
    st.subheader("ğŸ”® í”„ë¡œí•„")
    st.markdown(
        f"""
        - ì´ë¦„: **{profile.name}**  
        - ìƒë…„ì›”ì¼: **{profile.birthdate.strftime('%Y-%m-%d')}**  
        - ë³„ìë¦¬: **{profile.zodiac}** Â· 12ë : **{profile.zodiac_animal}ë ** Â· ì˜¤í–‰(ì›”ê¸°ì¤€): **{profile.element}**
        """
    )

    st.subheader("ğŸ§  ìƒë‹´ ê²°ê³¼")
    summary, tasks, support = advice_blocks(profile, category, concern)
    st.markdown(f"**ìš”ì•½:** {summary}")

    st.markdown("**ì‹¤í–‰ ì²´í¬ë¦¬ìŠ¤íŠ¸**")
    for t in tasks:
        st.checkbox(t, key=f"chk-{category}-{t}")

    st.markdown("**ì‘ì›/ê²©ë ¤**")
    for s in support:
        st.caption("â€¢ " + s)

    # í˜¸í¡ ê°€ì´ë“œ
    with st.expander("í˜¸í¡ ê°€ì´ë“œ(4-4-4 ë°•ìŠ¤í˜¸í¡)"):
        st.write("4ì´ˆ ë“¤ì´ë§ˆì‹œê³ , 4ì´ˆ ë©ˆì¶”ê³ , 4ì´ˆ ë‚´ì‰¬ê¸° â€” 4íšŒ ë°˜ë³µ")
        st.progress(0.0, text="3ì´ˆ í›„ ì‹œì‘â€¦")

    # ê°„ë‹¨ ë©”ëª¨/ì¼ê¸°
    st.subheader("ğŸ“ ì˜¤ëŠ˜ì˜ í•œ ì¤„ ê¸°ë¡")
    note = st.text_area("ì˜¤ëŠ˜ ëŠë‚€ ì ì´ë‚˜ ê²°ì‹¬ì„ ì ì–´ë³´ì", key="note")
    if st.button("ê¸°ë¡ ì €ì¥"):
        st.session_state.chat.append(("user", note))
        st.success("ì €ì¥í–ˆì–´ìš”. ì‘ì€ ê¸°ë¡ì´ í° ë³€í™”ë¥¼ ë§Œë“­ë‹ˆë‹¤ âœ¨")

with colR:
    st.subheader("ğŸ§ ë§ì¶¤ ë°°ê²½ìŒì•…")
    mm_key = f"{profile.birthdate.month:02d}-{category}"
    slot = st.session_state.music_map.get(mm_key)

    tab1, tab2 = st.tabs(["ì¬ìƒ", "ì„¤ì •/ê´€ë¦¬"])

    with tab1:
        # ì¬ìƒ ìš°ì„ ìˆœìœ„: ì—…ë¡œë“œ â†’ URL â†’ ë‚´ì¥ í•©ì„±
        played = False

        # 1) ì—…ë¡œë“œ ë§¤ì¹­
        if mm_key in st.session_state.uploaded_audio:
            st.write(f"ì—…ë¡œë“œ ë§¤ì¹­: **{slot.title}**")
            st.audio(st.session_state.uploaded_audio[mm_key])
            played = True
        else:
            # 2) URL ë§¤í•‘
            if slot and slot.url:
                st.write(f"URL ì¬ìƒ: **{slot.title}**")
                st.audio(slot.url)
                played = True

        # 3) ë‚´ì¥ í•©ì„± BGM (ê¸°ë³¸)
        if not played:
            st.write(f"ë‚´ì¥ ìƒì„± BGM: **{slot.title if slot else mm_key}**")
            # ì›”/ì¹´í…Œê³ ë¦¬ â†’ ì”¨ë“œ/ì£¼íŒŒìˆ˜
            seed = int(profile.birthdate.month * 10 + CATEGORIES.index(category) + 1)
            base = 174.61 + 12.0 * (profile.birthdate.month % 3)  # ë‹¬ì— ë”°ë¥¸ ìŒìƒ‰ ë³€í™”
            wav = synth_ambient(duration_s=90, seed=seed, base_hz=base)
            st.audio(wav, format="audio/wav")
            st.caption("â€» ì‹¤ì œ í´ë˜ì‹ ìŒì› ì—…ë¡œë“œ/URL ë“±ë¡ ì‹œ ìë™ ëŒ€ì²´ë©ë‹ˆë‹¤.")

    with tab2:
        st.markdown("**48ê°œ ìŠ¬ë¡ ë¯¸ë¦¬ë³´ê¸°** (ì›”Ã—ì¹´í…Œê³ ë¦¬)")
        sel_month = st.select_slider("ì›” ì„ íƒ", options=list(range(1, 13)), value=profile.birthdate.month)
        for c in CATEGORIES:
            key = f"{sel_month:02d}-{c}"
            item = st.session_state.music_map[key]
            st.text_input(f"{MONTHS_KR[sel_month-1]} Â· {c} Â· ì œëª©", value=item.title, key=f"title-{key}")
            new_url = st.text_input(f"{key} URL(mp3/ogg ë“±)", value=item.url or "", key=f"url-{key}")
            # ì„¸ì…˜ ë°˜ì˜
            st.session_state.music_map[key] = TrackInfo(title=st.session_state[f"title-{key}"], url=new_url or None, file_key=key)
            st.divider()

# ----------------------------- í•˜ë‹¨: ëª…í™•í•œ ê³ ì§€ -----------------------------
with st.expander("â„¹ï¸ í•´ì„/ì¡°ì–¸ ê³ ì§€"):
    st.write("""
    ì´ ì›¹ì•±ì˜ í•´ì„ì€ ë³„ìë¦¬Â·ì˜¤í–‰ì„ 'ì˜ê°'ìœ¼ë¡œ í™œìš©í•œ ì½”ì¹­ì…ë‹ˆë‹¤. 
    ì‹¤ì œ ì˜ì‚¬ê²°ì •ì€ ë³¸ì¸ì˜ íŒë‹¨ê³¼ ì£¼ë³€ ì–´ë¥¸/ì „ë¬¸ê°€ì™€ì˜ ìƒì˜ë¥¼ ë°”íƒ•ìœ¼ë¡œ í•´ì£¼ì„¸ìš”.
    ê±´ê°•/ì •ì‹ ê±´ê°•/ë²•ë¥ /ì¬ë¬´ ë“± ì „ë¬¸ ë¶„ì•¼ì˜ ë¬¸ì œëŠ” ë°˜ë“œì‹œ í•´ë‹¹ ì „ë¬¸ê°€ì˜ ë„ì›€ì„ ë°›ìœ¼ì„¸ìš”.
    """)

# í‘¸í„°
st.caption("Made with â¤ï¸ for í•™ìƒ ìƒë‹´ Â· Streamlit")

